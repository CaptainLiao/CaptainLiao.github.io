<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[wxss引用外部CSS文件及iconfont]]></title>
      <url>/2017/04/22/wxss%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8CSS%E6%96%87%E4%BB%B6%E5%8F%8Aiconfont/</url>
      <content type="html"><![CDATA[<p>小程序引入外部文件的方式是：@import “<em>/</em>.wxss”;</p>
<p>因为业务需要，正在开发的小程序中需要使用iconfont，很容易想到了H5的引入方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;font-family: &quot;iconfont&quot;;</div><div class="line">  src: url(&apos;iconfont.eot?t=1485242349767&apos;); /* IE9*/</div><div class="line">  src: url(&apos;iconfont.eot?t=1485242349767#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */</div><div class="line">  url(&apos;iconfont.woff?t=1485242349767&apos;) format(&apos;woff&apos;), /* chrome, firefox */</div><div class="line">  url(&apos;iconfont.ttf?t=1485242349767&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/</div><div class="line">  url(&apos;iconfont.svg?t=1485242349767#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */</div><div class="line">&#125;</div><div class="line"></div><div class="line">.iconfont &#123;</div><div class="line">  font-family:&quot;iconfont&quot; !important;</div><div class="line">  font-size:16px;</div><div class="line">  font-style:normal;</div><div class="line">  -webkit-font-smoothing: antialiased;</div><div class="line">  -moz-osx-font-smoothing: grayscale;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为此段css样式是通用的，就把它放在了lib/style/font.wxss中，此时文件目录如下：</p>
<p><img src="/img/引入外部css/1.png" alt=""></p>
<p>通过@import 的方式引入到需要用到的文件里，但是并没有效果。</p>
<p>原因：小程序的wxss文件font-face的url不接受http地址作为参数,可以接受base64,因此可以先将字体文件下载后,转换为base64，然后引用。</p>
<p>解决方案如下：</p>
<p>一、先到阿里巴巴矢量图标库(<a href="http://iconfont.cn/)生成自己的字体图标，并下载下来，找到ttf格式文件" target="_blank" rel="external">http://iconfont.cn/)生成自己的字体图标，并下载下来，找到ttf格式文件</a></p>
<p><img src="/img/引入外部css/2.png" alt=""></p>
<p>二、到这个平台<a href="https://transfonter.org/，把字体文件转化成base64格式" target="_blank" rel="external">https://transfonter.org/，把字体文件转化成base64格式</a></p>
<p><img src="/img/引入外部css/3.png" alt=""></p>
<p>三、在lib文件中引入</p>
<p><img src="/img/引入外部css/4.png" alt=""></p>
<p>四、在wxss加入字体</p>
<p><img src="/img/引入外部css/5.png" alt=""></p>
<p>五、显示效果</p>
<p><img src="/img/引入外部css/6.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wxss引用外部CSS文件及iconfont]]></title>
      <url>/2017/04/22/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      <content type="html"><![CDATA[<h2 id="事件代理-事件委托（event-delegation）"><a href="#事件代理-事件委托（event-delegation）" class="headerlink" title="事件代理/事件委托（event delegation）"></a>事件代理/事件委托（event delegation）</h2><p><strong>需求一：</strong>当一个div内部有多个事件发生，给每个元素逐个添加事件十分麻烦…</p>
<p><strong>需求二：</strong>在项目中我们常常需要动态的添加元素，不可避免的需要为那些未来添加的元素增加事件…<br><a id="more"></a><br><strong>我们：</strong>怎么办呢？</p>
<p><strong>事件委托：</strong>我可以！使用我能让你避免对特定的每个节点添加事件监听器。</p>
<p><strong>我们：</strong>你到底是什么鬼？ </p>
<p><strong>事件委托：</strong>我又叫事件代理，说白了就是利用浏览器事件捕获和冒泡的原理，将事件监听器添加到特定节点的父元素上，我就会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$(parentsEle).click(function (e) &#123;</div><div class="line">    var e = e || window.event,</div><div class="line">        targetEle = e.target || e.srcElement,</div><div class="line">        _this = this;</div><div class="line">    switch (targetEle.className) &#123;</div><div class="line">        case &quot;font_r&quot;:</div><div class="line">            $(targetEle).fadeOut();</div><div class="line">            _this.siblings(&quot;.header&quot;).fadeIn();</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>明白了吗？</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wxss引用外部CSS文件及iconfont]]></title>
      <url>/2017/04/22/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h2 id="快速搭建微信小程序开发环境"><a href="#快速搭建微信小程序开发环境" class="headerlink" title="快速搭建微信小程序开发环境"></a>快速搭建微信小程序开发环境</h2><p>1.工具软件：</p>
<p>注：本文介绍的工具软件已分享到百度云盘，直接下载并按照本文介绍安装即可。</p>
<a id="more"></a>
<p>开发工具 v0.7</p>
<p>百度云链接: <a href="https://pan.baidu.com/s/1jIQ7i8A密码" target="_blank" rel="external">https://pan.baidu.com/s/1jIQ7i8A密码</a>: aqn4<br>开发工具 v0.9</p>
<p>百度云链接: <a href="https://pan.baidu.com/s/1o7IHoN4" target="_blank" rel="external">https://pan.baidu.com/s/1o7IHoN4</a> 密码: r9c4<br>Demo源代码</p>
<p>百度云链接: <a href="https://pan.baidu.com/s/1o7T67ai" target="_blank" rel="external">https://pan.baidu.com/s/1o7T67ai</a> 密码: dp44</p>
<p> <img src="/img/20160923152531991.png" alt=""></p>
<p>2.搭建步骤：</p>
<p>1）、安装0.7 — 扫码登陆 — 关闭0.7<br>2）、安装0.9 ——不要启动程序——替换以下文件<br>文件在weapp-ide-crack-master文件夹中<br>替换目录<br>F:\Program Files (x86)\Tencent\微信web开发者工具\package.nw\app\dist\weapp\appservice\asdebug.js<br>F:\Program Files (x86)\Tencent\微信web开发者工具\package.nw\app\dist\components\create\createstep.js<br>F:\Program Files (x86)\Tencent\微信web开发者工具\package.nw\app\dist\stroes\projectStores.js<br>3）、打开0.9——新建项目：appid和名称随便填，路径选demo的路径</p>
<p>3.常见问题：</p>
<p>找不到所要替换的文件<br>问题原因：开发工具版本不正确，老版本不支持<br>解决方案：确保下载的程序版本在0.9.092100以上<br>Failed to load resource: net::ERR_NAME_NOT_RESOLVED <a href="http://1709827360.appservice.open.weixin.qq.com/appservice" target="_blank" rel="external">http://1709827360.appservice.open.weixin.qq.com/appservice</a><br>问题原因：通常是由于系统设置了代理如Shadowsocks等。<br>解决方案：关闭代理，或者依次点击工具栏“动作”-“设置”，选择“不使用任何代理，勾选后直连网络”。<br>修复asdebug.js报错<br>问题原因：TypeError: Cannot read property ‘MaxRequestConcurrent’ of undefined<br>解决方案：替换 /Resources/app.nw/app/dist/weapp/appservice/asdebug.js<br>扫码登录失败<br>问题原因：please bind your wechat account to the appid first<br>解决方案：先使用0.7版本的进行扫码登陆，登陆成功后，再用0.9的版本打开就直接进入了<br>百度云链接: <a href="https://pan.baidu.com/s/1jIQ7i8A" target="_blank" rel="external">https://pan.baidu.com/s/1jIQ7i8A</a> 密码: aqn4</p>
<p>invalid appid</p>
<p>如果按照教程安装扔出现上述问题，建议将原0.7和0.9版本卸载干净后再重新安装，记得使用替换以下文件：<br>链接: <a href="https://pan.baidu.com/s/1pLzY7yV" target="_blank" rel="external">https://pan.baidu.com/s/1pLzY7yV</a> 密码: tkwb<br>C:\Program Files (x86)\Tencent\微信web开发者工具\package.nw\app\dist\weapp\appservice\asdebug.js<br>C:\Program Files (x86)\Tencent\微信web开发者工具\package.nw\app\dist\components\create\createstep.js<br>C:\Program Files (x86)\Tencent\微信web开发者工具\package.nw\app\dist\stroes\projectStores.js</p>
<p>参考链接：</p>
<p>“小程序”破解IDE + Demo：<a href="https://github.com/gavinkwoe/weapp-ide-crack.git" target="_blank" rel="external">https://github.com/gavinkwoe/weapp-ide-crack.git</a><br>资源汇总：<a href="https://github.com/Aufree/awesome-wechat-weapp" target="_blank" rel="external">https://github.com/Aufree/awesome-wechat-weapp</a><br>官方简易教程·MINA：<a href="http://wxopen.notedown.cn/" target="_blank" rel="external">http://wxopen.notedown.cn/</a><br>Hello小程序 - 非官方：<a href="http://www.helloxcx.com" target="_blank" rel="external">http://www.helloxcx.com</a><br>微信应用号开发教程：<a href="https://my.oschina.net/wwnick/blog/750055" target="_blank" rel="external">https://my.oschina.net/wwnick/blog/750055</a></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/04/22/%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h2 id="函数的创建和重载"><a href="#函数的创建和重载" class="headerlink" title="函数的创建和重载"></a>函数的创建和重载</h2><p>今天做一个关注/取消的功能，由于需要向后台发送请求，想通过控制用户点击发送的频次减少不必要的请求，即在一定时间内，用户点击多次但只发送一次数据，自然而然想到了使用【函数节流】。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function throttle2(method, context) &#123;</div><div class="line">    clearTimeout(method.tId);</div><div class="line">    method.tId = setTimeout(function()&#123;</div><div class="line">        method.call(context);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但在实际应用中，并不能达到想要效果–每次点击都会发送一次数据，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">$(&quot;.daili_act_lia&quot;).click(function () &#123;</div><div class="line">    var checkbox = $(&quot;#s11&quot;),</div><div class="line">      options = &#123;&#125;,</div><div class="line">      isFocus = &apos;&apos;,</div><div class="line">         id = $(this).attr(&quot;data-id&quot;);</div><div class="line"></div><div class="line">             function throttle2(method, context) &#123;</div><div class="line">                 clearTimeout(method.tId);</div><div class="line">                 method.tId = setTimeout(function()&#123;</div><div class="line">                     method.call(context);</div><div class="line">                 &#125;, 1000);</div><div class="line">             &#125;</div><div class="line"></div><div class="line">             function myAjax() &#123;</div><div class="line">                 if(checkbox.prop(&quot;checked&quot;)) &#123;</div><div class="line">                     isFoucs = -1;</div><div class="line">                 &#125;else &#123;</div><div class="line">                     isFoucs = &apos;&apos;;</div><div class="line">                 &#125;</div><div class="line">                 options = &#123;</div><div class="line">                     focusId: id,</div><div class="line">                     tag: 2,</div><div class="line">                     focus: isFocus</div><div class="line">                 &#125;;</div><div class="line">                 console.log(options)</div><div class="line">                 function returnDate(json) &#123;</div><div class="line">                     console.log(json)</div><div class="line">                 &#125;</div><div class="line">                 Utils.getAjax(&quot;POST&quot;, CONFIG.API.editFocus, options, returnDate);</div><div class="line">             &#125;</div><div class="line">             throttle2(myAjax,this)</div><div class="line">         &#125;);</div></pre></td></tr></table></figure>
<p>一直不明白为什么。。。</p>
<p>最后把throttle函数修改为以下就成功了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function throttle2(method, context) &#123;</div><div class="line">    clearTimeout(context.tId);</div><div class="line">    context.tId = setTimeout(function()&#123;</div><div class="line">        method.call(context);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仔细分析，原来是每次 click 的时候，都重新创建了函数 ‘method’（本例中的 myAjax 函数），那么throttle在内部永远保存着一个定时器不会被清除。才会出现每次点击都会执行method的现象。</p>
<p><strong>结论：</strong><br>1、 创建函数的方式<br>　　1.1 function fn(){}  函数声明<br>　　1.2 var fn = function(){} 函数表达式<br>2、 函数名是一个指向函数对象的指针，每创建一个函数，都会在内存重新分配一个地址，即使拥有相同的函数名，他们也不是同一个函数。<br>3、 JavaScript 中，没有函数重载。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
